<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Finger Circuit</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        font-family: "Noto Sans", sans-serif;
        height: 100vh;
        width: 100vw;
      }

      .game-container {
        position: relative;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .title-banner {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        background: white;
        padding: 10px 0;
        border-radius: 0 0 20px 20px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        z-index: 10;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        height: 70px;
      }

      .title-banner h1 {
        color: black;
        font-size: 18px;
        margin: 0;
        letter-spacing: 1px;
        font-weight: normal;
      }

      .title-banner h2 {
        color: black;
        font-size: 14px;
        margin: 5px 0 0;
        font-weight: normal;
      }

      .highlight-red {
        color: #ff0000;
      }

      .map-container {
        flex: 1;
        position: relative;
        display: block;
        overflow: hidden;
        margin-bottom: 60px;
      }

      #gameCanvas {
        position: absolute;
        top: 0;
        width: 100%;
        height: 70%;
        margin: auto;
        left: 0;
        margin-top: 100px;
        right: 0;
        z-index: 1;
        display: block;
        max-width: 800px;
        border: 1px solid rgba(0, 0, 0, 0.1);
        touch-action: none;
        background-image: url("assets/map.svg");
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        aspect-ratio: 350/500;
      }

      .nav-bar {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: #ff0000;
        display: flex;
        justify-content: space-around;
        align-items: center;
        padding: 8px 0;
        z-index: 10;
        height: 60px;
      }

      .nav-icon {
        color: white;
        text-decoration: none;
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 10px;
        gap: 4px;
      }

      .nav-icon svg {
        height: 24px;
        width: auto;
      }

      .nav-icon span {
        margin-top: 2px;
      }

      .mission-banner {
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        margin-top: 50px;
        width: 80%;
        max-width: 400px;
        background: rgba(255, 255, 255, 0.95);
        padding: 15px 20px;
        text-align: center;
        z-index: 4;
        opacity: 1;
        transition: opacity 0.5s ease;
        border-radius: 10px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .mission-banner h2 {
        color: black;
        font-size: 18px;
        margin: 0;
        font-weight: bold;
      }

      .mission-banner p {
        color: black;
        font-size: 14px;
        margin: 8px 0 0;
      }

      .start-point {
        position: absolute;
        width: 100px;
        height: 40px;
        background-color: rgba(255, 102, 153, 0.7);
        border-radius: 20px;
        display: flex;
        justify-content: center;
        align-items: center;
        color: white;
        text-shadow: 0 0 3px rgba(0, 0, 0, 0.5);
        z-index: 3;
        opacity: 1;
        transition: opacity 0.5s ease;
        backdrop-filter: blur(1px);
      }

      .start-arrow {
        position: absolute;
        width: 30px;
        height: 40px;
        z-index: 3;
        opacity: 1;
        transition: opacity 0.5s ease;
      }

      .white-belt {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 5;
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        transition: opacity 0.5s ease;
      }

      .result-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 20;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        text-align: center;
      }

      .result-modal {
        width: 85%;
        max-width: 320px;
        background-color: #333;
        border-radius: 12px;
        padding: 20px 15px;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      .result-modal::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><path d="M30,20 L70,20 L80,30 L80,70 L70,80 L30,80 L20,70 L20,30 Z" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="1"/></svg>');
        background-size: 100px 100px;
        opacity: 0.2;
        z-index: -1;
      }

      .result-title-jp {
        color: white;
        font-size: 14px;
        margin-bottom: 5px;
      }

      .result-title-en {
        color: white;
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 15px;
        letter-spacing: 1px;
      }

      .completion-label {
        color: white;
        font-size: 14px;
        margin-bottom: 5px;
      }

      .completion-value {
        font-size: 80px;
        font-weight: bold;
        color: #ff6699;
        text-shadow: 0 0 15px #ff6699, 0 0 25px #ff6699;
        margin: 0;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-bottom: 15px;
      }

      .completion-value .percent {
        font-size: 24px;
        margin-left: 5px;
        color: #ff6699;
        text-shadow: 0 0 10px #ff6699;
      }

      .result-button {
        width: 100%;
        padding: 12px;
        border-radius: 30px;
        border: none;
        margin-bottom: 10px;
        font-size: 14px;
        cursor: pointer;
        text-align: center;
        font-weight: bold;
      }

      .share-button {
        background-color: #666;
        color: white;
      }

      .retry-button {
        background-color: #666;
        color: white;
      }

      .map-button {
        background-color: white;
        color: #333;
      }

      .touch-indicator {
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: transparent;
        pointer-events: none;
        transform: translate(-50%, -50%);
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s;
      }

      .start-tooltip {
        position: absolute;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        padding: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        font-size: 14px;
        max-width: 200px;
        text-align: center;
        z-index: 5;
        animation: pulse 2s infinite;
      }

      .share-modal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 30;
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }

      .share-content {
        width: 90%;
        max-width: 350px;
        background-color: white;
        border-radius: 30px;
        padding: 25px;
        display: flex;
        flex-direction: column;
        align-items: center;
        position: relative;
      }

      .share-title {
        font-size: 20px;
        margin-bottom: 20px;
        text-align: center;
      }

      .share-image {
        width: 100%;
        max-width: 300px;
        margin-bottom: 20px;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        border: 1px solid #eee;
      }
      
      /* Removed share-buttons, share-platform, and share-platform-icon styles */

      .close-share {
        position: absolute;
        top: 15px;
        right: 15px;
        background: none;
        border: none;
        font-size: 24px;
        cursor: pointer;
        color: #333;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 30px;
        height: 30px;
        border-radius: 50%;
      }

      .close-share:hover {
        background-color: rgba(0, 0, 0, 0.1);
      }
      
      /* Update universal share button styling to be more prominent */
      .universal-share-button {
        width: 60px;
        height: 60px;
        background-color: #2196F3;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 10px;
        box-shadow: 0 3px 5px rgba(0, 0, 0, 0.2);
        transition: background-color 0.3s, transform 0.1s;
      }
      
      .universal-share-button:hover {
        background-color: #0d8aee;
      }
      
      .universal-share-button:active {
        transform: scale(0.95);
      }

      .share-icon {
        width: 24px;
        height: 24px;
      }

      .share-loading {
        color: #666;
        font-size: 14px;
        margin: 20px 0;
      }

      @keyframes pulse {
        0% { transform: scale(1); }
        50% { transform: scale(1.05); }
        100% { transform: scale(1); }
      }

      @media screen and (max-height: 500px) {
        .title-banner {
          height: 50px;
          padding: 5px 0;
        }

        .title-banner h1 {
          font-size: 16px;
        }

        .title-banner h2 {
          font-size: 12px;
          margin-top: 2px;
        }

        #gameCanvas {
          height: 65%;
          margin-top: 60px;
          max-width: 600px;
        }

        .nav-bar {
          height: 50px;
          padding: 5px 0;
        }

        .nav-icon svg {
          height: 20px;
        }

        .nav-icon {
          font-size: 9px;
        }
      }

      @media screen and (max-height: 400px) {
        .title-banner h2 {
          display: none;
        }

        #gameCanvas {
          height: 60%;
          margin-top: 40px;
          max-width: 500px;
        }
      }

      @media screen and (min-width: 768px) {
        #gameCanvas {
          max-width: 1000px;
          height: 75%;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <canvas id="gameCanvas"></canvas>

      <div class="title-banner">
        <h1>
          FIN<span class="highlight-red">G</span>ER CIRC<span class="highlight-red">U</span>IT
        </h1>
        <h2>フィンガーサーキット</h2>
      </div>

      <div class="mission-banner">
        <h2>MISSION</h2>
        <p>青い補助線に沿ってサーキットを描いてみよう！</p>
      </div>

      <div id="startPoint" class="start-point">スタート</div>
      <div id="startArrow" class="start-arrow">
        <svg width="30" height="40" viewBox="0 0 30 40">
          <path d="M15 5 L15 35" stroke="#ff6699" stroke-width="3" />
          <path d="M15 5 L10 10" stroke="#ff6699" stroke-width="3" />
          <path d="M15 5 L20 10" stroke="#ff6699" stroke-width="3" />
        </svg>
      </div>

      <div id="whiteBelt" class="white-belt"></div>

      <div id="touchIndicator" class="touch-indicator"></div>

      <div id="resultScreen" class="result-screen">
        <div class="result-modal">
          <div class="result-title-jp">フィニッシュ！</div>
          <div class="result-title-en">FINISH !</div>
          <div class="completion-label">完成度</div>
          <div class="completion-value">
            <span id="accuracyResult"></span>
            <span class="percent">%</span>
          </div>
          <button id="shareButton" class="result-button share-button">
            SNSでシェアする
          </button>
          <button id="retryButton" class="result-button retry-button">
            もう一度遊ぶ
          </button>
          <button id="mapButton" class="result-button map-button">
            マップに戻る
          </button>
        </div>
      </div>

       <!-- Social Share Modal -->
       <div id="shareModal" class="share-modal">
        <div class="share-content">
          <button id="closeShare" class="close-share">×</button>
          <div class="share-title">Share Your Score !!!</div>
          <img id="shareImage" class="share-image" alt="Your score" />
          <button id="universalShareButton" class="universal-share-button">
            <svg class="share-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white">
              <path d="M0 0h24v24H0z" fill="none"/>
              <path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92 1.61 0 2.92-1.31 2.92-2.92s-1.31-2.92-2.92-2.92z"/>
            </svg>
          </button>
        </div>
      </div>

    <!-- Navigation bar -->
    <div class="nav-bar">
      <a href="index.html" class="nav-icon">
       
        <span>HOME</span>
      </a>
      <a href="#" class="nav-icon">
        
        <span>DRIVER</span>
      </a>
      <a href="#" class="nav-icon">
        
        <span>CIRCUIT</span>
      </a>
      <a href="#" class="nav-icon">
       
        <span></span>
      </a>
    </div>
  </div>


    <script>
      document.addEventListener("DOMContentLoaded", function () {
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const touchIndicator = document.getElementById("touchIndicator");

        const gameState = {
          status: "initializing",
          difficulty: "challenge",
          userPath: [],
          lastPoint: null,
          isDrawing: false,
          startPoint: { x: 0, y: 0 },
          startRadius: 8,
          circuitPath: [],
          segmentVisibility: [], // For segment visibility
          completionThreshold: 20,
          accuracy: 0,
          minDrawDistance: 1,
          interpolationPoints: 5,
          pathWidth: 15,
          redrawScheduled: false,
          touchActive: false,
          lastTouchTime: 0,
          
          // Path progression tracking for better accuracy calculation
          pathProgression: 0,
          lastSegmentIndex: 0,
          accuracyPoints: 0,
          totalPossiblePoints: 0,
          segmentsVisited: new Set(),
          visitedInOrder: [],
          minCircuitCoverage: 0.2,    // Lower threshold for completion
          fullLoopRequired: false,    // Don't require full loop
          lastCheckpointIndex: -1,
          
          // Flag to prevent drawing after completion
          circuitCompleted: false,
          
          // Flag to track if we're in the process of calculating accuracy
          calculatingAccuracy: false,
          
          // Flag to control straight line behavior when lifting finger
          preventStraightLines: true, // Changed to prevent connecting lines when lifting finger
          
          // Flag to allow completion without full circuit
          allowPartialCompletion: true, // Allow showing results even with partial completion
          
          // Minimum time (ms) before allowing completion check
          minPlayTime: 1000, // Reduced to allow quicker completion
          gameStartTime: 0,
          
          // Track if we're currently in a continuous drawing or starting a new segment
          isNewSegment: false,
          
          // Track segments that have been touched at least once
          touchedSegments: new Set(),
          
          // Track all segments (visible and invisible) for accuracy
          allSegmentsTouched: new Set(),
          
          // Track if we should check for completion on finger lift
          checkCompletionOnLift: true,
          
          // Quick completion when near end point
          quickCompletionEnabled: true,
          
          // Add additional flags to control completion checking
          justResumedDrawing: false,
          minDistanceAfterResume: 30,
          distanceSinceResume: 0,
          resumePoint: null,
          
          // Prevent accidental quick completions
          quickCompletionThreshold: 15
        };

        function resizeCanvas() {
          const container = canvas.parentElement;
          const availableWidth = Math.min(window.innerWidth, 800);
          const aspectRatio = 350 / 500;
          canvas.width = availableWidth;
          canvas.height = availableWidth / aspectRatio;
          const maxHeight = window.innerHeight * 0.7;
          if (canvas.height > maxHeight) {
            canvas.height = maxHeight;
            canvas.width = maxHeight * aspectRatio;
          }
          initializeCircuitPath();
          if (gameState.status === "playing" || gameState.status === "ready") {
            drawCircuit();
            if (gameState.userPath.length > 0) {
              drawUserPath();
            }
          }
        }

        window.addEventListener("resize", resizeCanvas);

        function initializeCircuitPath() {
          const baseCoordinates = [
            { x: 73, y: 150 }, { x: 75, y: 80 }, { x: 75, y: 50 }, { x: 100, y: 38 },
            { x: 115, y: 60 }, { x: 110, y: 95 }, { x: 100, y: 110 }, { x: 125, y: 120 },
            { x: 100, y: 150 }, { x: 115, y: 155 }, { x: 130, y: 180 }, { x: 90, y: 200 },
            { x: 90, y: 220 }, { x: 110, y: 240 }, { x: 140, y: 230 }, { x: 150, y: 250 },
            { x: 205, y: 230 }, { x: 180, y: 300 }, { x: 135, y: 340 }, { x: 200, y: 320 },
            { x: 225, y: 340 }, { x: 220, y: 430 }, { x: 270, y: 450 }, { x: 270, y: 420 },
            { x: 240, y: 300 }, { x: 200, y: 300 }, { x: 180, y: 270 }, { x: 73, y: 250 },
            { x: 73, y: 150 }
          ];

          const scaleX = canvas.width / 350;
          const scaleY = canvas.height / 500;

          gameState.startPoint = {
            x: baseCoordinates[0].x * scaleX,
            y: baseCoordinates[0].y * scaleY,
          };

          gameState.circuitPath = baseCoordinates.map((point) => ({
            x: point.x * scaleX,
            y: point.y * scaleY,
          }));

          // Initialize segmentVisibility with selective visibility to match the image (~10-12 visible segments)
          gameState.segmentVisibility = Array(gameState.circuitPath.length - 1).fill(0); // Default to hidden
          // Set visible segments based on the image pattern
          gameState.segmentVisibility[1] = 1;  // Start to first vertical
          gameState.segmentVisibility[4] = 1;  // Top loop curve
          gameState.segmentVisibility[9] = 1;  // S-curve start
          gameState.segmentVisibility[12] = 1; // S-curve to lower loop
          gameState.segmentVisibility[14] = 1; // Lower loop curve
          gameState.segmentVisibility[19] = 1; // Lower loop to top loop
          gameState.segmentVisibility[22] = 1; // Final approach

          positionStartElements();
          drawCircuit();
        }

        function positionStartElements() {
          const startPointElem = document.getElementById("startPoint");
          const startArrowElem = document.getElementById("startArrow");
          startPointElem.style.left = `${gameState.startPoint.x - 50}px`;
          startPointElem.style.top = `${gameState.startPoint.y + 150}px`;
          startArrowElem.style.left = `${gameState.startPoint.x - 25}px`;
          startArrowElem.style.top = `${gameState.startPoint.y + 60}px`;
        }

        function showStartTooltip() {
          const tooltip = document.createElement("div");
          tooltip.className = "start-tooltip";
          tooltip.style.left = `${gameState.startPoint.x - 100}px`;
          tooltip.style.top = `${gameState.startPoint.y + 100}px`;
          document.body.appendChild(tooltip);
          
          setTimeout(() => {
            if (document.body.contains(tooltip)) {
              document.body.removeChild(tooltip);
            }
          }, 5000);
          
          gameState.startTooltip = tooltip;
        }

        function drawCircuit() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Keep the existing drawing code for visible segments
          for (let i = 0; i < gameState.circuitPath.length - 1; i++) {
            if (gameState.segmentVisibility[i] === 1) {
              const current = gameState.circuitPath[i];
              const next = gameState.circuitPath[i + 1];
              
              ctx.beginPath();
              ctx.moveTo(current.x, current.y);
              
              if (i < gameState.circuitPath.length - 2 && gameState.segmentVisibility[i + 1] === 1) {
                const nextNext = gameState.circuitPath[i + 2];
                const xc = (current.x + next.x) / 2;
                const yc = (current.y + next.y) / 2;
                ctx.quadraticCurveTo(next.x, next.y, xc, yc);
              } else {
                ctx.lineTo(next.x, next.y);
              }
              
              ctx.strokeStyle = "rgba(0, 0, 180, 0.9)";
              ctx.lineWidth = 6;
              ctx.stroke();
            }
          }

          // Draw start point
          ctx.beginPath();
          ctx.arc(gameState.startPoint.x, gameState.startPoint.y, gameState.startRadius, 0, Math.PI * 2);
          ctx.fillStyle = "#ff6699";
          ctx.fill();

          // Add a pulsing effect to the start point
          if (gameState.status === "ready") {
            const pulseSize = gameState.startRadius * 1.5 + Math.sin(Date.now() / 200) * 3;
            ctx.beginPath();
            ctx.arc(gameState.startPoint.x, gameState.startPoint.y, pulseSize, 0, Math.PI * 2);
            ctx.strokeStyle = "#ff6699";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            if (gameState.status === "ready") {
              requestAnimationFrame(drawCircuit);
            }
          }
        }

        function drawUserPath() {
          if (gameState.userPath.length < 2) return;

          ctx.beginPath();

          // Draw each segment of the user path separately (no connections between lifted segments)
          let segments = [];
          let currentSegment = [];
          
          // First point is always the start of a segment
          currentSegment.push(gameState.userPath[0]);
          
          // Identify segments based on large distances (lifted finger)
          for (let i = 1; i < gameState.userPath.length; i++) {
            const prev = gameState.userPath[i-1];
            const curr = gameState.userPath[i];
            const distance = distanceBetween(prev, curr);
            
            // If distance is too large, it means the finger was lifted
            if (distance > 30) { // Threshold to detect lifted finger
              if (currentSegment.length > 0) {
                segments.push([...currentSegment]);
                currentSegment = [];
              }
            }
            
            currentSegment.push(curr);
          }
          
          // Add the last segment
          if (currentSegment.length > 0) {
            segments.push(currentSegment);
          }
          
          // Draw each segment with smooth curves
          for (const segment of segments) {
            if (segment.length < 2) continue;
            
            ctx.beginPath();
            ctx.moveTo(segment[0].x, segment[0].y);
            
            for (let i = 1; i < segment.length - 1; i++) {
              const current = segment[i];
              const next = segment[i + 1];
              const xc = (current.x + next.x) / 2;
              const yc = (current.y + next.y) / 2;
              ctx.quadraticCurveTo(current.x, current.y, xc, yc);
            }
            
            // Connect to the last point in the segment
            const last = segment[segment.length - 1];
            ctx.lineTo(last.x, last.y);
            
            // Apply stroke for current segment
            ctx.strokeStyle = "rgba(0, 0, 180, 0.9)"; // blue
            ctx.lineWidth = 3;
            ctx.lineCap = "round";
            ctx.lineJoin = "round";
            ctx.stroke();
          }

          drawCircuitOverlay();
        }

        function drawCircuitOverlay() {
          for (let i = 0; i < gameState.circuitPath.length - 1; i++) {
            if (gameState.segmentVisibility[i] === 1) {
              const current = gameState.circuitPath[i];
              const next = gameState.circuitPath[i + 1];
              
              ctx.beginPath();
              ctx.moveTo(current.x, current.y);
              
              if (i < gameState.circuitPath.length - 2 && gameState.segmentVisibility[i + 1] === 1) {
                const nextNext = gameState.circuitPath[i + 2];
                const xc = (current.x + next.x) / 2;
                const yc = (current.y + next.y) / 2;
                ctx.quadraticCurveTo(next.x, next.y, xc, yc);
              } else {
                ctx.lineTo(next.x, next.y);
              }
              
              ctx.strokeStyle = "rgba(0, 0, 180, 0.5)";
              ctx.lineWidth = 7;
              ctx.stroke();
            }
          }
        }

        function toggleSegmentVisibility(segmentIndex, visible) {
          if (segmentIndex >= 0 && segmentIndex < gameState.segmentVisibility.length) {
            gameState.segmentVisibility[segmentIndex] = visible ? 1 : 0;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawCircuit();
            if (gameState.userPath.length > 0) {
              drawUserPath();
            }
          }
        }

        function interpolatePoints(p1, p2, numPoints) {
          const points = [];
          for (let i = 0; i <= numPoints; i++) {
            const t = i / numPoints;
            points.push({
              x: p1.x + (p2.x - p1.x) * t,
              y: p1.y + (p2.y - p1.y) * t
            });
          }
          return points;
        }

        function findClosestPointOnPath(point) {
          let minDist = Infinity;
          let closestPoint = null;
          let closestSegmentIndex = -1;
          
          // Check all segments, not just visible ones
          for (let i = 0; i < gameState.circuitPath.length - 1; i++) {
            const p1 = gameState.circuitPath[i];
            const p2 = gameState.circuitPath[i + 1];
            
            const closest = closestPointOnSegment(point, p1, p2);
            const dist = distanceBetween(point, closest);
            
            if (dist < minDist) {
              minDist = dist;
              closestPoint = closest;
              closestSegmentIndex = i;
            }
          }
          
          return { 
            point: closestPoint, 
            distance: minDist,
            segmentIndex: closestSegmentIndex
          };
        }

        function closestPointOnSegment(p, v, w) {
          const l2 = distanceSquared(v, w);
          if (l2 === 0) return v;
          
          let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
          t = Math.max(0, Math.min(1, t));
          
          return {
            x: v.x + t * (w.x - v.x),
            y: v.y + t * (w.y - v.y)
          };
        }

        function distanceSquared(v, w) {
          return Math.pow(v.x - w.x, 2) + Math.pow(v.y - w.y, 2);
        }

        function distanceBetween(p1, p2) {
          return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function checkCompletion(forceCheck = false) {
          // Don't check completion if we're already completed or calculating
          if (gameState.circuitCompleted || gameState.calculatingAccuracy) return false;
          
          // Need a minimum path length
          if (gameState.userPath.length < 5) return false;
          
          // Need minimum play time before allowing completion check
          if (!forceCheck && Date.now() - gameState.gameStartTime < gameState.minPlayTime) return false;
          
          // Skip completion check if we just resumed drawing and haven't moved enough
          if (gameState.justResumedDrawing && gameState.distanceSinceResume < gameState.minDistanceAfterResume) {
            return false;
          }

          const lastPoint = gameState.userPath[gameState.userPath.length - 1];
          
          // Check if near start point
          const dxStart = lastPoint.x - gameState.startPoint.x;
          const dyStart = lastPoint.y - gameState.startPoint.y;
          const distanceToStart = Math.sqrt(dxStart * dxStart + dyStart * dyStart);
          
          // Check if near end point (which is the same as start point in a circuit)
          const endPoint = gameState.circuitPath[gameState.circuitPath.length - 1];
          const dxEnd = lastPoint.x - endPoint.x;
          const dyEnd = lastPoint.y - endPoint.y;
          const distanceToEnd = Math.sqrt(dxEnd * dxEnd + dyEnd * dyEnd);

          // Calculate percentage of segments touched
          const totalSegments = gameState.circuitPath.length - 1;
          const touchedSegmentCount = gameState.allSegmentsTouched.size;
          const segmentPercentage = touchedSegmentCount / totalSegments;
          
          // Check completion conditions
          let isCompleted = false;
          
          // Condition 1: Near start/end point with enough segments covered
          if ((distanceToStart < gameState.completionThreshold || 
               distanceToEnd < gameState.completionThreshold) &&
              segmentPercentage >= gameState.minCircuitCoverage) {
            isCompleted = true;
          }
          
          // Condition 2: Only check on explicit force check (lifting finger) with enough coverage
          if (forceCheck && gameState.allowPartialCompletion && 
              segmentPercentage >= gameState.minCircuitCoverage) {
            // Only if we're near the end point
            if (distanceToEnd < gameState.completionThreshold * 2) {
              isCompleted = true;
            }
          }
          
          // Condition 3: Quick completion only when very close to end point (prevents accidental triggers)
          if (gameState.quickCompletionEnabled && 
              distanceToEnd < gameState.quickCompletionThreshold &&
              segmentPercentage >= gameState.minCircuitCoverage) {
            isCompleted = true;
          }
          
          if (isCompleted) {
            // Set circuit as completed to prevent further drawing
            gameState.circuitCompleted = true;
            gameState.calculatingAccuracy = true;
            
            setTimeout(() => {
              calculateAccuracy();
              gameState.calculatingAccuracy = false;
              showResultScreen();
            }, 100);
            
            return true;
          }
          
          return false;
        }

        function calculateAccuracy() {
          // Calculate percentage based on number of circuit segments touched
          const totalSegments = gameState.circuitPath.length - 1;
          const touchedSegments = gameState.allSegmentsTouched.size;
          
          // If the user path is too short, accuracy is very low but not zero
          if (gameState.userPath.length < 5) {
            gameState.accuracy = 5; // Minimum accuracy score
            document.getElementById("accuracyResult").textContent = gameState.accuracy;
            return;
          }

          // Calculate raw coverage
          const rawCoverage = touchedSegments / totalSegments;
          
          // Convert coverage to percentage with adjusted weighting
          // This rewards touching more of the circuit
          const coverageScore = rawCoverage * 100;
          
          // Final accuracy calculation
          gameState.accuracy = Math.round(coverageScore);
          
          // Ensure accuracy is between 5 and 100
          gameState.accuracy = Math.max(5, Math.min(100, gameState.accuracy));

          // Update UI immediately
          document.getElementById("accuracyResult").textContent = gameState.accuracy;
        }

        function handleStart(e) {
          e.preventDefault();
          
          // Don't allow drawing if circuit is completed
          if (gameState.circuitCompleted) return;
          
          const pos = getEventPosition(e);
          gameState.touchActive = true;
          gameState.lastTouchTime = Date.now();

          if (gameState.status === "ready") {
            const distance = distanceBetween(pos, gameState.startPoint);
            if (distance < gameState.startRadius * 4) {
              gameState.isDrawing = true;
              gameState.status = "playing";
              gameState.gameStartTime = Date.now();
              gameState.userPath = [{ x: gameState.startPoint.x, y: gameState.startPoint.y }];
              gameState.lastPoint = { x: gameState.startPoint.x, y: gameState.startPoint.y };
              
              // Reset segment tracking
              gameState.touchedSegments = new Set();
              gameState.allSegmentsTouched = new Set(); // Track all segments
              gameState.visitedInOrder = [];
              gameState.lastCheckpointIndex = -1;
              
              document.getElementById("startPoint").style.opacity = "0";
              document.getElementById("startArrow").style.opacity = "0";
              
              if (gameState.startTooltip && document.body.contains(gameState.startTooltip)) {
                document.body.removeChild(gameState.startTooltip);
              }
              
              drawCircuit();
              drawUserPath();
            }
          } else if (gameState.status === "playing" && !gameState.isDrawing) {
            // Continue drawing from where user is touching now (don't connect with previous point)
            gameState.isDrawing = true;
            gameState.isNewSegment = true;
            
            // Track that we've just resumed drawing
            gameState.justResumedDrawing = true;
            gameState.distanceSinceResume = 0;
            gameState.resumePoint = { x: pos.x, y: pos.y };
            
            // Start a new segment at touch point instead of connecting with last point
            gameState.lastPoint = { x: pos.x, y: pos.y };
            gameState.userPath.push({ x: pos.x, y: pos.y });
            
            drawCircuit();
            drawUserPath();
          }
        }

        function handleMove(e) {
          e.preventDefault();
          
          if (gameState.circuitCompleted) return;
          if (!gameState.isDrawing) return;
          
          const pos = getEventPosition(e);
          gameState.touchActive = true;
          gameState.lastTouchTime = Date.now();

          let addPoint = true;
          if (gameState.lastPoint) {
            const dist = distanceBetween(pos, gameState.lastPoint);
            if (dist < gameState.minDrawDistance) {
              addPoint = false;
            }
          }

          if (addPoint) {
            if (gameState.lastPoint) {
              const dist = distanceBetween(pos, gameState.lastPoint);
              
              // Track distance moved since resuming drawing
              if (gameState.justResumedDrawing && gameState.resumePoint) {
                const distanceFromResume = distanceBetween(pos, gameState.resumePoint);
                gameState.distanceSinceResume = distanceFromResume;
                
                // If moved enough, stop flagging as just resumed
                if (distanceFromResume > gameState.minDistanceAfterResume) {
                  gameState.justResumedDrawing = false;
                }
              }
              
              if (dist > 10) {
                const interpolated = interpolatePoints(gameState.lastPoint, pos, gameState.interpolationPoints);
                
                for (let i = 1; i < interpolated.length; i++) {
                  gameState.userPath.push(interpolated[i]);
                  
                  // Check if point is on ANY circuit segment and track it
                  const closestInfo = findClosestPointOnPath(interpolated[i]);
                  if (closestInfo.distance <= gameState.pathWidth) {
                    // Track visible segments for UI feedback
                    if (gameState.segmentVisibility[closestInfo.segmentIndex] === 1) {
                      gameState.touchedSegments.add(closestInfo.segmentIndex);
                    }
                    // Track ALL segments (visible and invisible) for accuracy
                    gameState.allSegmentsTouched.add(closestInfo.segmentIndex);
                  }
                }
              } else {
                gameState.userPath.push({ x: pos.x, y: pos.y });
                
                // Check if point is on ANY circuit segment and track it
                const closestInfo = findClosestPointOnPath(pos);
                if (closestInfo.distance <= gameState.pathWidth) {
                  // Track visible segments for UI feedback
                  if (gameState.segmentVisibility[closestInfo.segmentIndex] === 1) {
                    gameState.touchedSegments.add(closestInfo.segmentIndex);
                  }
                  // Track ALL segments for accuracy
                  gameState.allSegmentsTouched.add(closestInfo.segmentIndex);
                }
              }
            } else {
              gameState.userPath.push({ x: pos.x, y: pos.y });
            }
            
            gameState.lastPoint = { x: pos.x, y: pos.y };
            gameState.isNewSegment = false;

            if (!gameState.redrawScheduled) {
              gameState.redrawScheduled = true;
              requestAnimationFrame(() => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawCircuit();
                drawUserPath();
                gameState.redrawScheduled = false;
              });
            }

            // Only check for completion if we're not just resuming drawing
            if (!gameState.justResumedDrawing) {
              checkCompletion();
            }
          }
        }

        function handleEnd(e) {
          e.preventDefault();
          
          if (gameState.isDrawing) {
            gameState.isDrawing = false;
            gameState.touchActive = false;
            
            // Reset the resumed drawing flag when lifting finger
            gameState.justResumedDrawing = false;
            
            // Check for completion when lifting finger if enabled
            if (gameState.checkCompletionOnLift && 
                gameState.allSegmentsTouched.size > 0) {
              // Only check if we've covered enough of the circuit
              const totalSegments = gameState.circuitPath.length - 1;
              const touchedSegmentCount = gameState.allSegmentsTouched.size;
              const segmentPercentage = touchedSegmentCount / totalSegments;
              
              if (segmentPercentage >= gameState.minCircuitCoverage) {
                // Check if we're near end point
                const lastPoint = gameState.userPath[gameState.userPath.length - 1];
                const endPoint = gameState.circuitPath[gameState.circuitPath.length - 1];
                const dx = lastPoint.x - endPoint.x;
                const dy = lastPoint.y - endPoint.y;
                const distanceToEnd = Math.sqrt(dx * dx + dy * dy);
                
                // Only force completion check if near end point
                if (distanceToEnd < gameState.completionThreshold * 2) {
                  checkCompletion(true); // Force check on finger lift near end point
                }
              }
            }
          }
        }

        function getEventPosition(e) {
          let x, y;
          try {
            if (e.type.includes("touch")) {
              const touch = e.touches[0] || e.changedTouches[0];
              if (!touch) return { x: 0, y: 0 };
              const rect = canvas.getBoundingClientRect();
              x = touch.clientX - rect.left;
              y = touch.clientY - rect.top;
            } else {
              const rect = canvas.getBoundingClientRect();
              x = e.clientX - rect.left;
              y = e.clientY - rect.top;
            }
            return { x, y };
          } catch (error) {
            console.error("Error in getEventPosition:", error);
            return { x: 0, y: 0 };
          }
        }

        function showResultScreen() {
          document.getElementById("accuracyResult").textContent = gameState.accuracy;
          document.getElementById("resultScreen").style.display = "flex";
        }

        function generateScoreCard() {
          return new Promise((resolve, reject) => {
            try {
              const scoreCanvas = document.createElement("canvas");
              const scoreCtx = scoreCanvas.getContext("2d");
              scoreCanvas.width = 320;
              scoreCanvas.height = 240;
              scoreCtx.fillStyle = "#333";
              scoreCtx.fillRect(0, 0, scoreCanvas.width, scoreCanvas.height);
              scoreCtx.strokeStyle = "rgba(255, 255, 255, 0.1)";
              scoreCtx.lineWidth = 1;
              for (let i = 0; i < 5; i++) {
                for (let j = 0; j < 5; j++) {
                  scoreCtx.beginPath();
                  scoreCtx.rect(i * 70, j * 60, 60, 50);
                  scoreCtx.stroke();
                }
              }
              scoreCtx.fillStyle = "white";
              scoreCtx.font = "14px 'Noto Sans', sans-serif";
              scoreCtx.textAlign = "center";
              scoreCtx.fillText("フィニッシュ！", scoreCanvas.width / 2, 40);
              scoreCtx.font = "bold 24px 'Noto Sans', sans-serif";
              scoreCtx.fillText("FINISH !", scoreCanvas.width / 2, 70);
              scoreCtx.font = "14px 'Noto Sans', sans-serif";
              scoreCtx.fillText("完成度", scoreCanvas.width / 2, 100);
              scoreCtx.font = "bold 80px 'Noto Sans', sans-serif";
              scoreCtx.fillStyle = "#ff6699";
              scoreCtx.shadowColor = "#ff6699";
              scoreCtx.shadowBlur = 15;
              scoreCtx.fillText(gameState.accuracy, scoreCanvas.width / 2 - 20, 170);
              scoreCtx.font = "bold 24px 'Noto Sans', sans-serif";
              scoreCtx.fillText("%", scoreCanvas.width / 2 + 50, 170);
              scoreCtx.shadowBlur = 0;
              scoreCtx.fillStyle = "white";
              scoreCtx.font = "12px 'Noto Sans', sans-serif";
              scoreCtx.fillText("FINGER CIRCUIT", scoreCanvas.width / 2, 210);
              const dataUrl = scoreCanvas.toDataURL("image/png");
              resolve(dataUrl);
            } catch (error) {
              reject(error);
            }
          });
        }

        function showShareModal() {
          document.getElementById("shareImage").style.display = "none";
          const loadingMsg = document.createElement("p");
          loadingMsg.className = "share-loading";
          loadingMsg.textContent = "Loading...";
          document.querySelector(".share-content").insertBefore(loadingMsg, document.getElementById("universalShareButton"));
          
          document.getElementById("shareModal").style.display = "flex";
          
          // Use a timeout to let the modal appear before generating the image
          setTimeout(() => {
            generateScoreCard()
              .then(imageUrl => {
                // Remove loading message
                if (loadingMsg.parentNode) {
                  loadingMsg.parentNode.removeChild(loadingMsg);
                }
                
                const shareImage = document.getElementById("shareImage");
                shareImage.src = imageUrl;
                shareImage.style.display = "block";
              })
              .catch(error => {
                console.error("Failed to generate score card:", error);
                if (loadingMsg.parentNode) {
                  loadingMsg.textContent = "Failed to generate score card";
                }
              });
          }, 100);
        }

        function shareResult() {
          showShareModal();
        }

        function shareToSocialMedia() {
          const imageUrl = document.getElementById("shareImage").src;
          const shareText = `I completed the Finger Circuit with ${gameState.accuracy}% accuracy!`;
          
          // Use Web Share API with error handling
          if (imageUrl) {
            fetch(imageUrl)
              .then(res => res.blob())
              .then(blob => {
                const file = new File([blob], "finger-circuit-score.png", { type: "image/png" });
                
                if (navigator.share) {
                  navigator.share({
                    title: "My Finger Circuit Result",
                    text: shareText,
                    files: [file]
                  }).catch(error => {
                    console.error("Error sharing:", error);
                    // Fallback for browsers that support share API but not file sharing
                    navigator.share({
                      title: "My Finger Circuit Result",
                      text: shareText,
                      url: window.location.href
                    }).catch(err => {
                      console.error("Error in fallback share:", err);
                      downloadImage(imageUrl);
                    });
                  });
                } else {
                  // Fallback for browsers that don't support Web Share API
                  downloadImage(imageUrl);
                }
              })
              .catch(error => {
                console.error("Error processing image:", error);
                alert("Couldn't process image for sharing. Please try again.");
              });
          }
        }

        function downloadImage(imageUrl) {
          const downloadLink = document.createElement('a');
          downloadLink.href = imageUrl;
          downloadLink.download = 'finger-circuit-score.png';
          document.body.appendChild(downloadLink);
          downloadLink.click();
          document.body.removeChild(downloadLink);
          
          alert("Image saved. You can share it manually.");
        }

        function returnToMap() {
          window.location.href = "index.html";
        }

        function resetGame() {
          // Reset game state
          gameState.status = "initializing";
          gameState.userPath = [];
          gameState.lastPoint = null;
          gameState.isDrawing = false;
          gameState.circuitCompleted = false;
          gameState.calculatingAccuracy = false;
          gameState.touchedSegments = new Set();
          gameState.allSegmentsTouched = new Set(); // Reset all segments tracking
          gameState.visitedInOrder = [];
          gameState.justResumedDrawing = false;
          gameState.distanceSinceResume = 0;
          gameState.resumePoint = null;
          
          // Hide result screen
          document.getElementById("resultScreen").style.display = "none";
          
          // Show start elements
          document.getElementById("startPoint").style.opacity = "1";
          document.getElementById("startArrow").style.opacity = "1";
          
          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          drawCircuit();
          
          // Show intro animation
          const whiteBelt = document.getElementById("whiteBelt");
          const missionBanner = document.querySelector(".mission-banner");
          whiteBelt.style.display = "flex";
          whiteBelt.style.opacity = "1";
          missionBanner.style.display = "block";
          missionBanner.style.opacity = "1";
          
          setTimeout(function () {
            whiteBelt.style.opacity = "0";
            setTimeout(function () {
              whiteBelt.style.display = "none";
              missionBanner.style.opacity = "0";
              setTimeout(function () {
                missionBanner.style.display = "none";
                gameState.status = "ready";
                drawCircuit();
                showStartTooltip();
              }, 500);
            }, 500);
          }, 2000);
        }

        function initGame() {
          try {
            // Initialize canvas and circuit
            resizeCanvas();
            initializeCircuitPath();
            drawCircuit();
            
            // Show intro animation
            const whiteBelt = document.getElementById("whiteBelt");
            const missionBanner = document.querySelector(".mission-banner");
            whiteBelt.style.display = "flex";
            whiteBelt.style.opacity = "1";
            missionBanner.style.opacity = "1";
            gameState.status = "initializing";
            
            setTimeout(function () {
              whiteBelt.style.opacity = "0";
              setTimeout(function () {
                whiteBelt.style.display = "none";
                missionBanner.style.opacity = "0";
                setTimeout(function () {
                  missionBanner.style.display = "none";
                  gameState.status = "ready";
                  drawCircuit();
                  showStartTooltip();
                }, 500);
              }, 500);
            }, 2000);

            // Remove any existing event listeners to prevent duplicates
            canvas.removeEventListener("mousedown", handleStart);
            canvas.removeEventListener("mousemove", handleMove);
            canvas.removeEventListener("mouseup", handleEnd);
            canvas.removeEventListener("touchstart", handleStart);
            canvas.removeEventListener("touchmove", handleMove);
            canvas.removeEventListener("touchend", handleEnd);

            // Add event listeners with passive: false to prevent scrolling
            canvas.addEventListener("mousedown", handleStart, { passive: false });
            canvas.addEventListener("mousemove", handleMove, { passive: false });
            canvas.addEventListener("mouseup", handleEnd, { passive: false });
            canvas.addEventListener("touchstart", handleStart, { passive: false });
            canvas.addEventListener("touchmove", handleMove, { passive: false });
            canvas.addEventListener("touchend", handleEnd, { passive: false });

            // Add button event listeners
            document.getElementById("retryButton").addEventListener("click", resetGame);
            document.getElementById("shareButton").addEventListener("click", shareResult);
            document.getElementById("mapButton").addEventListener("click", returnToMap);
            
            // Removed share platform event listeners
            
            // Keep universal share button event listener
            document.getElementById("universalShareButton").addEventListener("click", function() {
              shareToSocialMedia();
            });
            
            // Add close share modal event listener
            document.getElementById("closeShare").addEventListener("click", function() {
              document.getElementById("shareModal").style.display = "none";
            });
          } catch (error) {
            console.error("Error during game initialization:", error);
          }
        }

        // Start the game
        resizeCanvas();
        initGame();
      });
    </script>
  </body>
</html>